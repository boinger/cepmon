# vim:syntax=ruby
# "metric" events have attributes:  name, host, cluster, value

amqp_input :host => "localhost",
           :user => "guest",
           :password => "guest",
           :vhost => "/",
           :name => "stats",
           :type => "exchange"

#statement :name => "load_alert",
#          :epl => "select name, host, cluster, avg(value) from metric(name='system.load.5').win:length(2) having avg(value) > 3.0 output first every 5 minutes"

# only alert if the 95% percentile is over 2 seconds
#statement :name => "mysql_query_time",
#          :epl => "select name, host, cluster, tp(90, value) from metric(name='syncstorage.mysql.querytime.average').win:time(60 sec) having tp(90, value) > 2.0 output first every 5 minutes"

#m="system.load.5"
m="mysql.qps"

# keep a running 5 minute average, update every 2 minutes
statement :name => "00_metric_avg_5_host",
          :epl => "insert into metric_avg_5_host select name, host, cluster, avg(value) as value from metric.win:time(5 minutes) group by name, host, cluster output last every 2 minutes",
          :listen => false

# keep a running 5 minute average for the cluster-level value, update every 2 minutes
statement :name => "00_metric_avg_5_cluster",
          :epl => "insert into metric_avg_5_cluster select name, cluster, avg(value) as value from metric.win:time(5 minutes) group by name, cluster output last every 2 minutes",
          :listen => false

def forecast(metric)
  # prediction tracking (host level)
  statement :name => "10_predict_tracking_host_#{metric}",
            :epl => "insert into metric_predictions_host_#{metric} select metric.name as name, metric.value as value, metric.cluster as cluster, metric.host as host, predict.forecast as forecast, predict.lastRaw + 2.5 * predict.deviation as upper_bound, predict.lastRaw - 2.5 * predict.deviation as lower_bound from metric_avg_5_host(name = '#{metric}').cepmon:predict(value, 0.3, 0.5) as predict, metric_avg_5_host(name='#{metric}').win:length(1) as metric",
            :listen => false

  # prediction tracking (cluster level)
  statement :name => "10_predict_tracking_cluster",
            :epl => "insert into metric_predictions_cluster_#{metric} select metric.name as name, metric.value as value, metric.cluster as cluster, predict.forecast as forecast, predict.lastRaw + 2.5 * predict.deviation as upper_bound, predict.lastRaw - 2.5 * predict.deviation as lower_bound from metric_avg_5_cluster(name='#{metric}').cepmon:predict(value, 0.3, 0.5) as predict, metric_avg_5_cluster(name='#{metric}').win:length(1) as metric group by metric.name, metric.cluster",
            :listen => false

  # host forecast alerts
  statement :name => "20_forecast_alerting_host",
            :epl => "select name, host, cluster, value, upper_bound, lower_bound from metric_predictions_host_#{metric}.win:length(1) where upper_bound != lower_bound having value > upper_bound or value < lower_bound"

  # cluster forecast alerts
  statement :name => "20_forecast_alerting_cluster",
            :epl => "select name, cluster, value, upper_bound, lower_bound from metric_predictions_cluster_#{metric}.win:length(1) where upper_bound != lower_bound having value > upper_bound or value < lower_bound"
end

forecast('mysql.qps')
